/*

Inside of our install callback, we need to take the following steps:
	Open a cache.
Cache our files.
Confirm whether all the required assets are cached or not.
*/

var CACHE_NAME = 'my-site-cache-v1';
var urlsToCache = [	
	'/assets/bs/4.0.0/bootstrap.min.css',
	'/assets/pk2/css/paper-kit.css',	
	'/assets/pk2/css/nucleo-icons.css',
	'/build/css/app.css',
	'/bundles/sonatacore/vendor/components-font-awesome/css/font-awesome.min.css',
	'/assets/codemirror/codemirror.min.css',
	'/assets/froala/2.8.4/froala_editor.pkgd.min.css',
	'/assets/froala/2.8.4/froala_style.min.css',
	'/assets/pz_main/pinch_zoomer/css/pinchzoomer.min.css',
	'/assets/pz_main/pinch_zoomer/js/hammer.min.js',
	'/assets/pz_main/pinch_zoomer/js/TweenMax.min.js',
	'/assets/pz_main/pinch_zoomer/js/jquery.pinchzoomer.min.js',
	'/assets/pz_main/complete_guide/css/tooltipster.bundle.min.css',
	'/assets/pz_main/pinch_zoomer/js/tooltipster.bundle.min.js'
];


self.addEventListener('install', function(event) {
	// Perform install steps
	event.waitUntil(
		caches.open(CACHE_NAME)
		.then(function(cache) {
			console.log('Opened cache');
			return cache.addAll(urlsToCache);
		})
	);
});

self.addEventListener('fetch', function (event) {
    console.log('The service worker is serving the asset.');
    event.respondWith(fromNetwork(event.request, 400).catch(function () {
        return fromCache(event.request);
    }));

    /**
     * If we want to cache new requests cumulatively,
     * we can do so by handling the response of the fetch request
     * and then adding it to the cache, like below.
     */
    // event.respondWith(
    //     caches.match(event.request)
    //         .then(function (response) {
    //             // Cache hit - return response
    //             if (response) {
    //                 return response;
    //             }
    //
    //             // IMPORTANT: Clone the request. A request is a stream and
    //             // can only be consumed once. Since we are consuming this
    //             // once by cache and once by the browser for fetch, we need
    //             // to clone the response.
    //             var fetchRequest = event.request.clone();
    //
    //             return fetch(fetchRequest).then(
    //                 function (response) {
    //                     // Check if we received a valid response
    //                     if (!response || response.status !== 200 || response.type !== 'basic') {
    //                         return response;
    //                     }
    //
    //                     // IMPORTANT: Clone the response. A response is a stream
    //                     // and because we want the browser to consume the response
    //                     // as well as the cache consuming the response, we need
    //                     // to clone it so we have two streams.
    //                     var responseToCache = response.clone();
    //
    //                     caches.open(CACHE_NAME)
    //                         .then(function (cache) {
    //                             // cache.put(event.request, responseToCache);
    //                         });
    //
    //                     return response;
    //                 }
    //             );
    //         })
    // );
});

function fromNetwork(request, timeout) {
    return new Promise(function (fulfill, reject) {

        var timeoutId = setTimeout(reject, timeout);
        fetch(request).then(function (response) {
            clearTimeout(timeoutId);
            fulfill(response);
        }, reject);
    });
}

function fromCache(request) {
    return caches.open(CACHE_NAME).then(function (cache) {
        return cache.match(request).then(function (matching) {
            return matching || Promise.reject('no-match');
        });
    });
}